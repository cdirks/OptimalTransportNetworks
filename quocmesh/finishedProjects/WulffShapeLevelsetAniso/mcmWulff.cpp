/*
 * Copyright (c) 2001-2014 AG Rumpf, INS, Universitaet Bonn                      *
 *                                                                               *
 * The contents of this file are subject to the terms of the Common Development  *
 * and Distribution License Version 1.0 (the "License"); you may not use       *
 * this file except in compliance with the License. You may obtain a copy of     *
 * the License at http://www.opensource.org/licenses/CDDL-1.0                    *
 *                                                                               *
 * Software distributed under the License is distributed on an "AS IS" basis,  *
 * WITHOUT WARRANTY OF ANY KIND, either expressed or implied.                    *
 */

#include <configurators.h>
#include <quoc.h>
#include <FEOpInterface.h>
#include <solver.h>
#include <preconditioner.h>

#include <mcm.h>
#include <fastUniformGridMatrix.h>

#include <anisotropies.h>
#include <Willmore.h>

#include <qmException.h>
#include <aol.h>
#include <parameterParser.h>
#include "grapeInterface3d.h"
#include <timestepSaver.h>

typedef qc::QuocConfiguratorTraitMultiLin<double, qc::QC_3D, aol::GaussQuadrature<double,qc::QC_3D,3> > ConfigType;

using namespace aol::color;

// typedef qc::SinePolygonRotated3d<double> AnisoType;
// typedef qc::RotatedEllipsoidAnisotropy<double> AnisoType;
typedef qc::Rotated3dAnisotropy<double, qc::LInfNorm2d<double> > AnisoType;


double norm(qc::ScalarArray<double, qc::QC_3D> &Data, int N)
{
  double res = 0.;
  for (int i=0; i<N; i++)
    for (int j=0; j<N; j++)
      for (int k=0; k<N; k++)
        res += Data.get(i,j,k);

  return res;
}






// now the main program
int main( int argc, char **argv ) {

  // read the parameters with an parameter-file
  if ( argc != 2 ) {
    string s = "USAGE: ";
    s += argv[0];
    s += " <parameterfile>";
    throw aol::Exception( s.c_str(), __FILE__, __LINE__  );
  }

  try {
    aol::ParameterParser parser( argv[1] );

    // ---------- load image into scalar array -------------

    char saveName[ 1024 ];
    parser.getString( "saveName", saveName );

    aol::TimestepSaver<double> tsSaver( parser.getInt("timeOffset"), saveName );

    char imgname[ 1024 ];
    parser.getString( "image", imgname );
    cerr<<green<<"\nLoading file "<<imgname<<"...\n\n"<<reset;
    qc::ScalarArray<double, qc::QC_3D> img( imgname );
    cerr<<green<<"done."<<reset;

    int N = img.getNumX ();
    int d = qc::logBaseTwo (N);

    qc::GridDefinition grid( d, qc::QC_3D );

    qc::ScalarArray<double, qc::QC_3D> rhs( N,N,N );
    qc::ScalarArray<double, qc::QC_3D> rhs2( N,N,N );
    qc::ScalarArray<double, qc::QC_3D> img_start( img );

    double eps = 5. * grid.H();

    // -------------- Operator - definitions -------------------------------

    qc::MCMLumpedMassOp< ConfigType > mcmMass( grid, eps, aol::DO_NOT_INVERT );


    // ******** the operator for the rhs including the anisotropy ***********
//     qcEllipsoidAnisotropy<double> ellipsoid(  1.,1.,1.,   eps);
//     qc::RotatedEllipsoidAnisotropy<double> aniso(  3.5,1.,1.,   eps);
    // Ellipsoid in Diagonale drehen
//     aol::Vec3<double> v(1.0,0,0);
//     ellipsoid.setRotateDirection(v);

    // **** Anisotropy = cone ****
    // **** generated by a rotated Linf-norm ****
    qc::LInfNorm2d<double> LInfAniso( eps );
    qc::Rotated3dAnisotropy<double, qc::LInfNorm2d<double> > aniso( LInfAniso, grid.H() );

    // p-Norm als Franck-Diagramm => q-Norm als Wulffshape
//     qcLpAnisotropy3d<double> qNorm(  10., 0.1,  eps);



    qc::AnisotropyIntegrationOp< ConfigType, AnisoType >
      mcmAnisoInt( grid, aniso );

    qc::AnisotropyStiffOp< ConfigType, AnisoType >
       mcmAnisoStiff( grid, aol::ASSEMBLED, aniso, eps );


//     qc::AnisotropyIntegrationOp< ConfigType, qcLpAnisotropy3d<double> >
//       mcmAnisoInt( grid, qNorm );
//
//     qc::AnisotropyStiffOp< ConfigType, qcLpAnisotropy3d<double> >
//        mcmAnisoStiff( grid, aol::ASSEMBLED, img, qNorm, eps );


    qc::FastUniformGridMatrix<double, qc::QC_3D> mat( grid );

    aol::StopWatch watch;           // Stoppuhr
    watch.start();

    // set the last time-step as data to calc |grad u|
    mcmAnisoStiff.setImageReference( img );
    mcmMass.setImageReference( img );

    double tau = 0.5 * aol::Sqr( parser.getDouble("tau") * grid.H() );
    double lambda = parser.getDouble("lambda");

    // filling the image-array with senseful values
    //img /= img.getMaxValue();

    aol::SSORPreconditioner<aol::Vector<double>, qc::FastUniformGridMatrix<double,qc::QC_3D> > precond( mat );
    aol::PCGInverse<aol::Vector<double> > solver( mat, precond, 1e-16, 1000 );

    // ------------------ the loop over the timesteps ----------------------------
    cerr<<endl<<endl;



    for ( int iter=0; iter<parser.getInt("timesteps"); ++iter ) {

      // the integral over gamma_z * phi
      cerr << blue << "step " << iter << ": "<<reset<< "Applying integrationOp...";
      mcmAnisoInt.apply( img, rhs );

      rhs *= -tau;

      // now: M + Tau*lambda*L
      mcmMass.reset();

      mat.setZero();

      cerr << "assembling and applying (M + Tau*lambda*L).";
      mcmAnisoStiff.assembleAddMatrix( mat );
      cerr << ".";

      mat *= tau*lambda;

      mcmMass.assembleAddMatrix( mat );      // this adds to the already assembled matrix
      cerr << ".done, finishing rhs ...";


      cerr << "done.\nSolving ...";

      solver.applyAdd( rhs, img );
      cerr<< ".done\n";

      // ------------------ save every 10 th timestep ------------------------
      tsSaver.saveTimestepBZ2( iter, img, grid );

    }


    watch.stop();
    cerr << "elapsed = " << watch.elapsedCpuTime() << "s.\n";


  } catch ( aol::Exception &ex ) {
    ex.dump();
  }

  return EXIT_SUCCESS;

}
